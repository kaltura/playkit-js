## API Report File for "@playkit-js/playkit-js"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ILogger } from 'js-logger';
import { ILogHandler } from 'js-logger';
import { ILogLevel } from 'js-logger';

// @public (undocumented)
export const AbrMode: {
    readonly MANUAL: "manual";
    readonly AUTO: "auto";
};

// @public (undocumented)
export const AdBreakType: {
    readonly PRE: "preroll";
    readonly MID: "midroll";
    readonly POST: "postroll";
    readonly OVERLAY: "overlay";
};

// @public (undocumented)
export const AdEventType: {
    readonly AD_CAN_SKIP: "adcanskip";
    readonly AD_MANIFEST_LOADED: "admanifestloaded";
    readonly AD_LOADED: "adloaded";
    readonly AD_STARTED: "adstarted";
    readonly AD_RESUMED: "adresumed";
    readonly AD_PAUSED: "adpaused";
    readonly AD_CLICKED: "adclicked";
    readonly AD_SKIPPED: "adskipped";
    readonly AD_COMPLETED: "adcompleted";
    readonly AD_ERROR: "aderror";
    readonly ADS_COMPLETED: "adscompleted";
    readonly ALL_ADS_COMPLETED: "alladscompleted";
    readonly AD_BREAK_START: "adbreakstart";
    readonly AD_BREAK_END: "adbreakend";
    readonly AD_FIRST_QUARTILE: "adfirstquartile";
    readonly AD_MIDPOINT: "admidpoint";
    readonly AD_THIRD_QUARTILE: "adthirdquartile";
    readonly USER_CLOSED_AD: "userclosedad";
    readonly AD_VOLUME_CHANGED: "advolumechanged";
    readonly AD_MUTED: "admuted";
    readonly AD_PROGRESS: "adprogress";
    readonly AD_BUFFERING: "adbuffering";
    readonly AD_WATERFALLING: "adwaterfalling";
    readonly AD_WATERFALLING_FAILED: "adwaterfallingfailed";
    readonly AD_AUTOPLAY_FAILED: "adautoplayfailed";
};

// @public (undocumented)
export const AdTagType: {
    readonly VAST: "vast";
    readonly VMAP: "vmap";
};

// @public
export class AudioTrack extends Track {
}

// Warning: (ae-forgotten-export) The symbol "PKAutoPlayTypes" needs to be exported by the entry point playkit.d.ts
//
// @public (undocumented)
export const AutoPlayType: PKAutoPlayTypes;

// @public (undocumented)
export class BaseMediaSourceAdapter extends FakeEventTarget implements IMediaSourceAdapter {
    constructor(videoElement: HTMLVideoElement, source: PKMediaSourceObject, config?: any);
    // (undocumented)
    applyABRRestriction(restrictions: PKABRRestrictionObject): void;
    // (undocumented)
    attachMediaSource(): void;
    static canPlayType(mimeType: string, preferNative: boolean): boolean;
    get capabilities(): PKMediaSourceCapabilities;
    protected _capabilities: PKMediaSourceCapabilities;
    protected _config: any;
    destroy(): Promise<void>;
    // (undocumented)
    detachMediaSource(): void;
    disableNativeTextTracks(): void;
    // (undocumented)
    enableAdaptiveBitrate(): void;
    protected _eventManager: EventManager;
    // (undocumented)
    getDrmInfo(): PKDrmDataObject | null;
    // (undocumented)
    protected _getLiveEdge(): number;
    static getLogger: (name?: string) => ILogger;
    // (undocumented)
    getSegmentDuration(): number;
    // (undocumented)
    getStartTimeOfDvrWindow(): number;
    // (undocumented)
    getThumbnail(time: number): ThumbnailInfo | null;
    handleMediaError(event?: MediaError): boolean;
    // (undocumented)
    hideTextTrack(): void;
    static id: string;
    // (undocumented)
    isAdaptiveBitrateEnabled(): boolean;
    // (undocumented)
    isLive(): boolean;
    static isMSESupported(): boolean;
    // (undocumented)
    isOnLiveEdge(): boolean;
    static isSupported(): boolean;
    // (undocumented)
    get liveDuration(): number;
    // (undocumented)
    load(): Promise<{
        tracks: Track[];
    }>;
    protected _loadPromise: Promise<{
        tracks: Array<Track>;
    }> | undefined;
    // (undocumented)
    protected static _logger: ILogger;
    protected _onTrackChanged(track: VideoTrack | AudioTrack | TextTrack_2 | ImageTrack): void;
    // (undocumented)
    seekToLiveEdge(): void;
    // (undocumented)
    selectAudioTrack(audioTrack: AudioTrack): void;
    // (undocumented)
    selectImageTrack(imageTrack: ImageTrack): void;
    // (undocumented)
    selectTextTrack(textTrack: TextTrack_2): void;
    // (undocumented)
    selectVideoTrack(videoTrack: VideoTrack): void;
    // (undocumented)
    setMaxBitrate(bitrate: number): void;
    protected _sourceObj?: PKMediaSourceObject;
    get src(): string;
    set src(source: string);
    // (undocumented)
    get targetBuffer(): number;
    protected _trigger(name: string, payload?: any): void;
    protected _videoElement: HTMLVideoElement;
}

// @public
export class BaseMiddleware {
    callNext(next: (...args: any[]) => any): void;
    id: string;
}

// @public (undocumented)
function binarySearch<T>(list?: Array<T>, comparisonFn?: ((param: T) => number)): T | null;

// @public (undocumented)
export type CapabilityResult = {
    [capabilityName: string]: any;
};

// @public (undocumented)
export const CorsType: {
    readonly ANONYMOUS: "anonymous";
    readonly USE_CREDENTIALS: "use-credentials";
};

// @public
export function createTextTrackCue(timedMetadata: TimedMetadata): PKTextTrackCue | null;

// @public
export function createTimedMetadata(cue: TextTrackCue): TimedMetadata | null;

// @public (undocumented)
export const CustomEventType: {
    readonly MEDIA_LOADED: "medialoaded";
    readonly PLAYER_RESET: "playerreset";
    readonly PLAYER_DESTROY: "playerdestroy";
    readonly ENTER_FULLSCREEN: "enterfullscreen";
    readonly EXIT_FULLSCREEN: "exitfullscreen";
    readonly PLAY_FAILED: "playfailed";
    readonly AUTOPLAY_FAILED: "autoplayfailed";
    readonly FALLBACK_TO_MUTED_AUTOPLAY: "fallbacktomutedautoplay";
    readonly CHANGE_SOURCE_STARTED: "changesourcestarted";
    readonly CHANGE_SOURCE_ENDED: "changesourceended";
    readonly MUTE_CHANGE: "mutechange";
    readonly VIDEO_TRACK_CHANGED: "videotrackchanged";
    readonly AUDIO_TRACK_CHANGED: "audiotrackchanged";
    readonly TEXT_TRACK_CHANGED: "texttrackchanged";
    readonly IMAGE_TRACK_CHANGED: "imagetrackchanged";
    readonly TEXT_TRACK_ADDED: "texttrackadded";
    readonly TEXT_CUE_CHANGED: "textcuechanged";
    readonly TRACKS_CHANGED: "trackschanged";
    readonly ABR_MODE_CHANGED: "abrmodechanged";
    readonly PLAYER_STATE_CHANGED: "playerstatechanged";
    readonly PLAYBACK_START: "playbackstart";
    readonly FIRST_PLAY: "firstplay";
    readonly FIRST_PLAYING: "firstplaying";
    readonly PLAYBACK_ENDED: "playbackended";
    readonly SOURCE_SELECTED: "sourceselected";
    readonly TEXT_STYLE_CHANGED: "textstylechanged";
    readonly MEDIA_RECOVERED: "mediarecovered";
    readonly VR_STEREO_MODE_CHANGED: "vrstereomodechanged";
    readonly FPS_DROP: "fpsdrop";
    readonly BOOKMARK_ERROR: "bookmarkerror";
    readonly CONCURRENCY_LIMIT: "concurrencylimit";
    readonly RESIZE: "resize";
    readonly TIMED_METADATA: "timedmetadata";
    readonly TIMED_METADATA_CHANGE: "timedmetadatachange";
    readonly TIMED_METADATA_ADDED: "timedmetadataadded";
    readonly FRAG_LOADED: "fragloaded";
    readonly MANIFEST_LOADED: "manifestloaded";
    readonly USER_GESTURE: "usergesture";
    readonly DRM_LICENSE_LOADED: "drmlicenseloaded";
    readonly SOURCE_URL_SWITCHED: "sourceurlswitched";
};

// @public (undocumented)
export type DeferredPromise = {
    resolve: (value?: any | PromiseLike<any>) => void;
    reject: (reason?: any) => void;
    catch: (param: () => any) => void;
    then(param: () => void): any;
};

// @public (undocumented)
const _Dom: {
    addClassName(element: HTMLElement, className: string): void;
    removeClassName(element: HTMLElement, className: string): void;
    hasClassName(element: HTMLElement, className: string): boolean;
    setAttribute(element: HTMLElement, name: string, value: string): void;
    removeAttribute(element: HTMLElement, name: string): void;
    setStyle(element: HTMLElement, name: string, value: string): void;
    appendChild(parent?: HTMLElement, child?: HTMLElement): void;
    removeChild(parent?: Node | null, child?: HTMLElement): void;
    prependTo(child: HTMLElement, parent: HTMLElement): void;
    getElementById(id: string): any;
    getElementsByTagName(tagName: string): any;
    createElement(tagName: string): any;
    loadStyleSheetAsync(url: string): Promise<HTMLLinkElement>;
    loadScriptAsync(url: string): Promise<any>;
    getElementBySelector(selector: string): any;
    insertBefore(parent: HTMLElement, newChild: HTMLElement, existingChild?: HTMLElement | null): HTMLElement | null;
};

// @public (undocumented)
export const DrmScheme: {
    WIDEVINE: string;
    PLAYREADY: string;
    FAIRPLAY: string;
};

// @public (undocumented)
export class EngineDecoratorProvider implements IEngineDecoratorProvider {
    constructor(plugin: IEngineDecoratorProvider);
    // (undocumented)
    getEngineDecorator(engine: IEngine, dispatchEventHandler: (event: FakeEvent) => void): IEngineDecorator;
    // (undocumented)
    getName(): string;
}

// @public (undocumented)
export const EngineType: {
    readonly HTML5: "html5";
    readonly FLASH: "flash";
    readonly SILVERLIGHT: "silverlight";
    readonly CAST: "cast";
    readonly YOUTUBE: "youtube";
    readonly IMAGE: "image";
};

// Warning: (ae-forgotten-export) The symbol "IEnv" needs to be exported by the entry point playkit.d.ts
//
// @public (undocumented)
export const Env: IEnv;

// @public
class Error_2 {
    constructor(severity: number, category: number, code: number, data?: any);
    // Warning: (ae-forgotten-export) The symbol "CategoryType" needs to be exported by the entry point playkit.d.ts
    static Category: CategoryType;
    // (undocumented)
    category: number;
    // Warning: (ae-forgotten-export) The symbol "CodeType" needs to be exported by the entry point playkit.d.ts
    static Code: CodeType;
    // (undocumented)
    code: number;
    // (undocumented)
    data: any;
    // Warning: (ae-forgotten-export) The symbol "SeverityType" needs to be exported by the entry point playkit.d.ts
    static Severity: SeverityType;
    // (undocumented)
    severity: number;
}
export { Error_2 as Error }

// @public
export class EventManager {
    constructor();
    // @override
    destroy(): Promise<void>;
    listen(target: EventTarget | FakeEventTarget, type: string, listener: ListenerType, options?: any): void;
    // Warning: (ae-forgotten-export) The symbol "ListenerType" needs to be exported by the entry point playkit.d.ts
    listenOnce(target: EventTarget | FakeEventTarget, type: string, listener: ListenerType, options?: any): void;
    removeAll(): void;
    unlisten(target: any, type: string, listener?: ListenerType): void;
}

// @public (undocumented)
export const EventType: PKEventTypes;

// @public
export class FakeEvent {
    constructor(type: string, payload?: any);
    bubbles: boolean;
    cancelable: boolean;
    currentTarget: any;
    defaultPrevented: boolean;
    isTrusted: boolean;
    // (undocumented)
    payload: any;
    // @override
    preventDefault(): void;
    // @override
    stopImmediatePropagation(): void;
    stopped: boolean;
    // @override
    stopPropagation(): void;
    target: any;
    timeStamp: number | Date;
    type: string;
}

// @public
export class FakeEventTarget {
    constructor();
    // Warning: (ae-forgotten-export) The symbol "EventListener_2" needs to be exported by the entry point playkit.d.ts
    //
    // @override
    addEventListener(type: string, listener: typeof EventListener_2): void;
    // @override
    dispatchEvent(event: FakeEvent): boolean;
    // @override
    removeEventListener(type: string, listener: typeof EventListener_2): void;
}

// @public
export function filterTracksByRestriction(videoTracks: VideoTrack[], restriction: PKABRRestrictionObject): VideoTrack[];

// @public (undocumented)
export type FontScaleOptions = -2 | -1 | 0 | 2 | 3 | 4;

// @public (undocumented)
export type FontSizeOptions = '50%' | '75%' | '100%' | '200%' | '300%' | '400%';

// @public (undocumented)
const _Generator: {
    uniqueId: (length?: number) => string;
    guid: () => string;
};

// @public (undocumented)
export const getCapabilities: typeof Player.getCapabilities;

// @public
export function getLogger(name?: string): ILogger;

// @public
export function getLogLevel(name?: string): ILogLevel;

// @public (undocumented)
export const Html5EventType: {
    readonly ABORT: "abort";
    readonly CAN_PLAY: "canplay";
    readonly CAN_PLAY_THROUGH: "canplaythrough";
    readonly DURATION_CHANGE: "durationchange";
    readonly EMPTIED: "emptied";
    readonly ENDED: "ended";
    readonly ERROR: "error";
    readonly LOADED_DATA: "loadeddata";
    readonly LOADED_METADATA: "loadedmetadata";
    readonly LOAD_START: "loadstart";
    readonly PAUSE: "pause";
    readonly PLAY: "play";
    readonly PLAYING: "playing";
    readonly PROGRESS: "progress";
    readonly RATE_CHANGE: "ratechange";
    readonly SEEKED: "seeked";
    readonly SEEKING: "seeking";
    readonly STALLED: "stalled";
    readonly SUSPEND: "suspend";
    readonly TIME_UPDATE: "timeupdate";
    readonly VOLUME_CHANGE: "volumechange";
    readonly WAITING: "waiting";
    readonly ENTER_PICTURE_IN_PICTURE: "enterpictureinpicture";
    readonly LEAVE_PICTURE_IN_PICTURE: "leavepictureinpicture";
    readonly PRESENTATION_MODE_CHANGED: "webkitpresentationmodechanged";
};

// @public (undocumented)
const _Http: {
    protocol: string;
    execute: (url: string, params: any, method?: string, headers?: Map<string, string>, timeout?: number, ontimeout?: ((...args: any[]) => any) | undefined) => Promise<any>;
    jsonp: typeof jsonp;
    convertHeadersToDictionary: (headerRow: string) => {
        [header: string]: string;
    };
};

// @public (undocumented)
export interface ICapability {
    // (undocumented)
    getCapability(): Promise<CapabilityResult>;
    // (undocumented)
    runCapability(): void;
    // (undocumented)
    setCapabilities(capabilities: {
        [name: string]: any;
    }): void;
}

// @public (undocumented)
export interface IDrmProtocol {
    // (undocumented)
    canPlayDrm(drmData: Array<PKDrmDataObject>): boolean;
    // (undocumented)
    isConfigured(drmData: Array<PKDrmDataObject>, drmConfig: PKDrmConfigObject): boolean;
    // (undocumented)
    setDrmPlayback(...any: any[]): void;
}

// @public (undocumented)
export interface IEngine extends FakeEventTarget {
    // (undocumented)
    addTextTrack(kind: TextTrackKind, label?: string, language?: string): TextTrack | undefined;
    // (undocumented)
    applyABRRestriction(restrictions: PKABRRestrictionObject): void;
    // (undocumented)
    attach(): void;
    // (undocumented)
    attachMediaSource(): void;
    // (undocumented)
    autoplay: boolean;
    // (undocumented)
    availableBuffer: number;
    // (undocumented)
    buffered: TimeRanges;
    // (undocumented)
    controls: boolean;
    // (undocumented)
    crossOrigin: string | null;
    // (undocumented)
    currentTime: number;
    // (undocumented)
    defaultMuted: boolean;
    // (undocumented)
    defaultPlaybackRate: number;
    // (undocumented)
    destroy(): void;
    // (undocumented)
    detach(): void;
    // (undocumented)
    detachMediaSource(): void;
    // (undocumented)
    duration: number;
    // (undocumented)
    enableAdaptiveBitrate(): void;
    // (undocumented)
    ended: boolean;
    // (undocumented)
    enterPictureInPicture(): void;
    // (undocumented)
    error: MediaError | null;
    // (undocumented)
    exitPictureInPicture(): void;
    // (undocumented)
    getDrmInfo(): PKDrmDataObject | null;
    // (undocumented)
    getNativeTextTracks(): TextTrack[];
    // (undocumented)
    getStartTimeOfDvrWindow(): number;
    // (undocumented)
    getThumbnail(time: number): ThumbnailInfo | null;
    // (undocumented)
    getVideoElement(): HTMLVideoElement;
    // (undocumented)
    hideTextTrack(): void;
    // (undocumented)
    id: string;
    // (undocumented)
    isAdaptiveBitrateEnabled(): boolean;
    // (undocumented)
    isInPictureInPicture: boolean;
    // (undocumented)
    isLive(): boolean;
    // (undocumented)
    isOnLiveEdge(): boolean;
    // (undocumented)
    isPictureInPictureSupported(): boolean;
    // (undocumented)
    liveDuration: number;
    // (undocumented)
    load(startTime?: number): Promise<{
        tracks: Track[];
    }>;
    // (undocumented)
    loop: boolean;
    // (undocumented)
    muted: boolean;
    // (undocumented)
    networkState: number;
    // (undocumented)
    pause(): void;
    // (undocumented)
    paused: boolean;
    // (undocumented)
    play(): Promise<any> | undefined;
    // (undocumented)
    playbackRate: number;
    // (undocumented)
    playbackRates: Array<number>;
    // (undocumented)
    played: TimeRanges;
    // (undocumented)
    playsinline: boolean;
    // (undocumented)
    poster: string;
    // (undocumented)
    preload: "none" | "metadata" | "auto" | "";
    // (undocumented)
    readyState: number;
    // (undocumented)
    reset(): void;
    // (undocumented)
    resetAllCues(): void;
    // (undocumented)
    restore(source: PKMediaSourceObject, config: Object): void;
    // (undocumented)
    seekable: TimeRanges;
    // (undocumented)
    seeking: boolean;
    // (undocumented)
    seekToLiveEdge(): void;
    // (undocumented)
    selectAudioTrack(audioTrack: AudioTrack): void;
    // (undocumented)
    selectImageTrack(imageTrack: ImageTrack): void;
    // (undocumented)
    selectTextTrack(textTrack: TextTrack_2): void;
    // (undocumented)
    selectVideoTrack(videoTrack: VideoTrack): void;
    // (undocumented)
    src: string;
    // (undocumented)
    targetBuffer: number;
    // (undocumented)
    videoHeight: number;
    // (undocumented)
    videoWidth: number;
    // (undocumented)
    volume: number;
}

// @public (undocumented)
export interface IEngineDecorator {
    // (undocumented)
    active: boolean;
    // (undocumented)
    attach?: () => void;
    // (undocumented)
    attachMediaSource?: () => void;
    // (undocumented)
    autoplay?: boolean;
    // (undocumented)
    availableBuffer?: number;
    // (undocumented)
    buffered?: TimeRanges;
    // (undocumented)
    controls?: boolean;
    // (undocumented)
    crossOrigin?: string;
    // (undocumented)
    currentTime?: number;
    // (undocumented)
    defaultMuted?: boolean;
    // (undocumented)
    defaultPlaybackRate?: number;
    // (undocumented)
    destroy?: () => void;
    // (undocumented)
    detach?: () => void;
    // (undocumented)
    detachMediaSource?: () => void;
    // (undocumented)
    dispatchEvent(event: FakeEvent): boolean;
    // (undocumented)
    duration?: number;
    // (undocumented)
    enableAdaptiveBitrate?: () => void;
    // (undocumented)
    ended?: boolean;
    // (undocumented)
    enterPictureInPicture?: () => void;
    // (undocumented)
    error?: MediaError;
    // (undocumented)
    exitPictureInPicture?: () => void;
    // (undocumented)
    getStartTimeOfDvrWindow?: () => number;
    // (undocumented)
    getVideoElement?: () => HTMLVideoElement;
    // (undocumented)
    hideTextTrack?: () => void;
    // (undocumented)
    id?: string;
    // (undocumented)
    isAdaptiveBitrateEnabled?: () => boolean;
    // (undocumented)
    isInPictureInPicture?: boolean;
    // (undocumented)
    isLive?: () => boolean;
    // (undocumented)
    isPictureInPictureSupported?: () => boolean;
    // (undocumented)
    load?: (startTime?: number) => Promise<any>;
    // (undocumented)
    loop?: boolean;
    // (undocumented)
    muted?: boolean;
    // (undocumented)
    networkState?: number;
    // (undocumented)
    pause?: () => void;
    // (undocumented)
    paused?: boolean;
    // (undocumented)
    play?: () => void;
    // (undocumented)
    playbackRate?: number;
    // (undocumented)
    playbackRates?: Array<number>;
    // (undocumented)
    played?: TimeRanges;
    // (undocumented)
    playsinline?: boolean;
    // (undocumented)
    poster?: string;
    // (undocumented)
    preload?: string;
    // (undocumented)
    readyState?: number;
    // (undocumented)
    reset?: () => void;
    // (undocumented)
    resetAllCues?: () => void;
    // (undocumented)
    restore?: (source: PKMediaSourceObject, config: any) => void;
    // (undocumented)
    seekable?: TimeRanges;
    // (undocumented)
    seeking?: boolean;
    // (undocumented)
    seekToLiveEdge?: () => void;
    // (undocumented)
    selectAudioTrack?: (audioTrack: AudioTrack) => void;
    // (undocumented)
    selectTextTrack?: (textTrack: TextTrack_2) => void;
    // (undocumented)
    selectVideoTrack?: (videoTrack: VideoTrack) => void;
    // (undocumented)
    src?: string;
    // (undocumented)
    targetBuffer?: number;
    // (undocumented)
    videoHeight?: number;
    // (undocumented)
    videoWidth?: number;
    // (undocumented)
    volume?: number;
}

// @public (undocumented)
export interface IEngineDecoratorProvider {
    // (undocumented)
    getEngineDecorator(engine: IEngine, dispatchEventHandler: Function): IEngineDecorator;
    // (undocumented)
    getName(): string;
}

// @public (undocumented)
export interface IEngineStatic {
    // (undocumented)
    canPlaySource(source: PKMediaSourceObject, preferNative: boolean, drmConfig: PKDrmConfigObject): boolean;
    // (undocumented)
    createEngine(source: PKMediaSourceObject, config: Object, playerId: string): IEngine;
    // (undocumented)
    getCapabilities(): Promise<any>;
    // (undocumented)
    id: string;
    // (undocumented)
    isSupported(): boolean;
    // (undocumented)
    prepareVideoElement(playerId: string): void;
    // (undocumented)
    runCapabilities(): void;
    // (undocumented)
    setCapabilities(capabilities: {
        [name: string]: any;
    }): void;
}

// @public (undocumented)
export type ImageSourceOptions = {
    thumbnailAPIParams: {
        [parmaName: string]: string;
    };
};

// @public (undocumented)
export class ImageTrack extends Track {
    constructor(settings: {
        id: string;
        active: boolean;
        index: number;
        url: string;
        width: number;
        height: number;
        duration: number;
        rows: number;
        cols: number;
        customData: any;
    });
    // (undocumented)
    get cols(): number;
    // (undocumented)
    get customData(): any;
    // (undocumented)
    get duration(): number;
    // (undocumented)
    get height(): number;
    // (undocumented)
    get rows(): number;
    // (undocumented)
    get sliceHeight(): number;
    // (undocumented)
    get sliceWidth(): number;
    // (undocumented)
    get url(): string;
    // (undocumented)
    get width(): number;
}

// @public (undocumented)
export interface IMediaSourceAdapter extends FakeEventTarget {
    // (undocumented)
    applyABRRestriction(restriction: PKABRRestrictionObject): void;
    // (undocumented)
    attachMediaSource(): void;
    // (undocumented)
    capabilities: PKMediaSourceCapabilities;
    // (undocumented)
    destroy(): Promise<any>;
    // (undocumented)
    detachMediaSource(): void;
    // (undocumented)
    disableNativeTextTracks(): void;
    // (undocumented)
    enableAdaptiveBitrate(): void;
    // (undocumented)
    getDrmInfo(): PKDrmDataObject | null;
    // (undocumented)
    getSegmentDuration(): number;
    // (undocumented)
    getStartTimeOfDvrWindow(): number;
    // (undocumented)
    getThumbnail(time: number): ThumbnailInfo | null;
    // (undocumented)
    handleMediaError(error?: MediaError): boolean;
    // (undocumented)
    hideTextTrack(): void;
    // (undocumented)
    isAdaptiveBitrateEnabled(): boolean;
    // (undocumented)
    isLive(): boolean;
    // (undocumented)
    isOnLiveEdge(): boolean;
    // (undocumented)
    liveDuration: number;
    // (undocumented)
    load(startTime?: number): Promise<{
        tracks: Track[];
    }>;
    // (undocumented)
    seekToLiveEdge(): void;
    // (undocumented)
    selectAudioTrack(audioTrack: AudioTrack): void;
    // (undocumented)
    selectImageTrack(imageTrack: ImageTrack): void;
    // (undocumented)
    selectTextTrack(textTrack: TextTrack_2): void;
    // (undocumented)
    selectVideoTrack(videoTrack: VideoTrack): void;
    // (undocumented)
    setMaxBitrate(bitrate: number): void;
    // (undocumented)
    src: string;
    // (undocumented)
    targetBuffer: number;
}

// @public (undocumented)
export interface IMediaSourceAdapterStatic {
    // (undocumented)
    canPlayDrm(drmData: Array<Object>, drmConfig: PKDrmConfigObject): boolean;
    // (undocumented)
    canPlayType(mimeType: string): boolean;
    // (undocumented)
    createAdapter(videoElement: HTMLVideoElement, source: PKMediaSourceObject, config: Object): IMediaSourceAdapter;
    // (undocumented)
    id: string;
    // (undocumented)
    isMSESupported(): boolean;
    // (undocumented)
    isSupported(): boolean;
}

// @public (undocumented)
function loadPlayer(config: any): Player;
export default loadPlayer;
export { loadPlayer }

// @public (undocumented)
export type LoggerLevels = {
    TRACE: ILogLevel;
    TIME: ILogLevel;
    ERROR: ILogLevel;
    INFO: ILogLevel;
    DEBUG: ILogLevel;
    WARN: ILogLevel;
    OFF: ILogLevel;
};

// @public (undocumented)
export const LogLevel: LoggerLevels;

// @public (undocumented)
export const LogLevelType: Record<keyof LoggerLevels, keyof LoggerLevels>;

// @public (undocumented)
export type MaybeState = State | null;

// @public (undocumented)
export const MediaType: {
    readonly VOD: "Vod";
    readonly LIVE: "Live";
    readonly AUDIO: "Audio";
    readonly IMAGE: "Image";
    readonly UNKNOWN: "Unknown";
};

// @public (undocumented)
const MimeType_2: PKMimeTypes;
export { MimeType_2 as MimeType }

// @public
class MultiMap<K, T> {
    constructor();
    clear(): void;
    get(key: K): Array<T>;
    getAll(): T[];
    has(key: K): boolean;
    keys(): Iterator<K>;
    push(key: K, value: T): void;
    remove(key: K, value: T): void;
    set(key: K, values: T[]): void;
}

// @public (undocumented)
export const NAME: string;

// @public (undocumented)
const _Number: {
    isNumber: (n: number) => boolean;
    isInt: (n: number) => boolean;
    isFloat: (n: number) => boolean;
};

// @public (undocumented)
const _Object: {
    merge: (objects: Array<any>) => any;
    isObject: (item: any) => boolean;
    isClassInstance: (item: any) => boolean;
    mergeDeep: (target: any, ...sources: any) => any;
    copyDeep: (data: any) => any;
    isEmptyObject: (obj: object) => boolean;
    getPropertyPath: (obj: object, propertyPath: string) => any;
    hasPropertyPath: (obj: object, propertyPath: string) => boolean;
    createPropertyPath: (obj: object, path: string, value?: any) => any;
    deletePropertyPath: (obj: object, path: string) => void;
    defer: () => DeferredPromise;
    bind: (thisObj: any, fn: (...args: any[]) => any) => (...args: any[]) => any;
};

// @public (undocumented)
export type PKAbrConfigObject = {
    fpsDroppedMonitoringThreshold: number;
    fpsDroppedFramesInterval: number;
    capLevelOnFPSDrop: boolean;
};

// @public (undocumented)
export type PKABRRestrictionObject = {
    minHeight: number;
    maxHeight: number;
    minWidth: number;
    maxWidth: number;
    minBitrate: number;
    maxBitrate: number;
};

// @public (undocumented)
export type PKAdBreakOptions = {
    type?: string;
    position?: number;
    numAds?: number;
};

// @public (undocumented)
export type PKAdOptions = {
    system?: string;
    url?: string;
    contentType?: string;
    title?: string;
    position?: number;
    duration?: number;
    clickThroughUrl?: string;
    posterUrl?: string;
    skipOffset?: number;
    linear: boolean;
    width: number;
    height: number;
    bitrate: number;
    bumper: boolean;
    inStream?: boolean;
    vpaid?: boolean;
    streamId?: string;
    wrapperAdIds: Array<string>;
    wrapperCreativeIds: Array<string>;
    wrapperAdSystems: Array<string>;
};

// @public (undocumented)
export type PKCustomLabelsConfigObject = {
    audio: Function;
    qualities: Function;
    video: Function;
};

// @public (undocumented)
export type PKDimensionsConfig = {
    width: number;
    height: number;
    ratio?: string;
};

// @public (undocumented)
export type PKDrmConfigObject = {
    keySystem: string;
};

// @public (undocumented)
export type PKDrmDataObject = {
    licenseUrl: string;
    scheme: string;
    certificate?: string;
};

// @public (undocumented)
export type PKEventTypes = typeof Html5EventType & typeof CustomEventType & typeof AdEventType;

// @public (undocumented)
export type PKExternalThumbnailsConfig = {
    vttUrl: string;
};

// @public (undocumented)
export type PKLogConfigObject = {
    level: string;
    handler?: ILogHandler;
};

// @public (undocumented)
export type PKMediaSourceCapabilities = {
    [fpsControl: string]: boolean;
};

// @public (undocumented)
export type PKMediaSourceObject = {
    mimetype: string;
    url: string;
    id?: string;
    bandwidth: number;
    width: number;
    height: number;
    drmData?: Array<PKDrmDataObject>;
};

// @public (undocumented)
export type PKMediaSourceOptionsObject = {
    forceRedirectExternalStreams: boolean;
    redirectExternalStreamsHandler?: Function;
    redirectExternalStreamsTimeout?: number;
};

// @public (undocumented)
export type PKMetadataConfigObject = {
    name?: string;
    description?: string;
    mediaType?: string;
    metas?: Object;
    tags?: Object;
    epgId?: string;
    recordingId?: string;
};

// @public (undocumented)
export type PKMimeTypes = {
    [mime: string]: Array<string>;
};

// @public (undocumented)
export type PKNetworkConfigObject = {
    requestFilter?: Function;
    responseFilter?: Function;
    maxStaleLevelReloads: number;
};

// @public (undocumented)
export type PKOrientationType = {
    [type: string]: string;
};

// @public (undocumented)
export type PKPlaybackConfigObject = {
    audioLanguage: string;
    textLanguage: string;
    captionsDisplay: boolean;
    additionalAudioLanguage: string;
    additionalTextLanguage: string;
    volume: number;
    playsinline: boolean;
    crossOrigin: string;
    preload: string;
    autoplay: PKAutoPlayTypes;
    allowMutedAutoPlay: boolean;
    muted: boolean;
    pictureInPicture: boolean;
    streamPriority: Array<PKStreamPriorityObject>;
    preferNative: PKPreferNativeConfigObject;
    inBrowserFullscreen: boolean;
    playAdsWithMSE: boolean;
    screenLockOrientionMode: string;
};

// @public (undocumented)
export type PKPlaybackOptionsObject = {
    html5: {
        hls: Object;
        dash: Object;
    };
};

// @public (undocumented)
export type PKPlayerDimensions = {
    width: number;
    height: number;
};

// @public (undocumented)
export type PKPlayOptionsObject = {
    programmatic: boolean;
};

// @public (undocumented)
export type PKPreferNativeConfigObject = {
    hls: boolean;
    dash: boolean;
};

// @public (undocumented)
export type PKRequestObject = {
    url: string;
    body: ArrayBuffer | ArrayBufferView | string | null;
    headers: {
        [header: string]: string;
    };
};

// @public (undocumented)
export type PKRequestType = {
    [request: string]: number;
};

// @public (undocumented)
export type PKResponseObject = {
    url: string;
    originalUrl: string;
    data: ArrayBuffer | ArrayBufferView;
    headers: {
        [header: string]: string;
    };
};

// @public (undocumented)
export type PKSessionConfigObject = {
    id?: string;
    ks?: string;
    isAnonymous?: boolean;
    partnerId?: number;
    uiConfId?: number;
};

// @public (undocumented)
export type PKSourcesConfigObject = {
    hls: Array<PKMediaSourceObject>;
    dash: Array<PKMediaSourceObject>;
    progressive: Array<PKMediaSourceObject>;
    image: Array<PKMediaSourceObject>;
    captions?: Array<PKExternalCaptionObject>;
    thumbnails?: PKExternalThumbnailsConfig;
    options: PKMediaSourceOptionsObject;
    type: string;
    dvr: boolean;
    metadata: PKMetadataConfigObject;
    id?: string;
    poster?: string;
    duration?: number;
    startTime?: number;
    vr?: any;
    imageSourceOptions?: ImageSourceOptions;
    seekFrom?: number;
    clipTo?: number;
};

// @public (undocumented)
export type PKStatsObject = {
    targetBuffer: number;
    availableBuffer: number;
};

// @public (undocumented)
export type PKStreamingConfigObject = {
    forceBreakStall: boolean;
    lowLatencyMode: boolean;
    trackEmsgEvents: boolean;
    switchDynamicToStatic: boolean;
};

// @public (undocumented)
export type PKStreamPriorityObject = {
    engine: string;
    format: string;
};

// @public (undocumented)
export type PKStreamTypes = Record<'DASH' | 'HLS' | 'PROGRESSIVE' | 'IMAGE', PlayerStreamTypes>;

// @public (undocumented)
export interface PKTextConfigObject {
    // (undocumented)
    captionsTextTrack1Label: string;
    // (undocumented)
    captionsTextTrack1LanguageCode: string;
    // (undocumented)
    captionsTextTrack2Label: string;
    // (undocumented)
    captionsTextTrack2LanguageCode: string;
    // (undocumented)
    enableCEA708Captions: boolean;
    // (undocumented)
    forceCenter: boolean;
    // (undocumented)
    textStyle: PKTextStyleObject;
    // (undocumented)
    textTrackDisplaySetting: PKTextTrackDisplaySettingObject;
    // (undocumented)
    useNativeTextTrack: boolean;
    // (undocumented)
    useShakaTextTrackDisplay: boolean;
}

// @public
export type PKTextStyleObject = {
    fontSize: FontSizeOptions;
    fontScale: FontScaleOptions;
    fontFamily: string;
    fontColor: [number, number, number];
    fontOpacity: number;
    fontEdge: Array<[number, number, number, number, number, number]>;
    backgroundColor: [number, number, number];
    backgroundOpacity: number;
};

// @public (undocumented)
export interface PKTextTrackCue extends TextTrackCue {
    // (undocumented)
    type?: string;
    // (undocumented)
    value: {
        key: string;
        data: string | any;
    };
}

// @public (undocumented)
export type PKTextTrackDisplaySettingObject = {
    line: string | number;
    lineAlign: string;
    align: string;
    position: number;
    positionAlign: string;
    snapToLines: boolean;
    vertical: string;
    size: number;
};

// @public (undocumented)
export type PKThumbnailVttCue = {
    startTime: number;
    endTime: number;
    imgUrl: string;
    coordinates: {
        x: number;
        y: number;
    } | null;
    size: {
        height: number;
        width: number;
    } | null;
};

// @public (undocumented)
export type PKTrackTypes = {
    [track: string]: string;
};

// @public (undocumented)
export type PKVideoDimensionsObject = {
    videoHeight: number;
    videoWidth: number;
};

// @public (undocumented)
export type PKVideoElementStore = {
    [id: string]: HTMLVideoElement;
} | {};

// @public
export class Player extends FakeEventTarget {
    constructor(config?: any);
    get AbrMode(): typeof AbrMode;
    get AdBreakType(): typeof AdBreakType;
    addTextTrack(kind: TextTrackKind, label?: string, language?: string): TextTrack | undefined;
    get AdTagType(): typeof AdTagType;
    attachMediaSource(): void;
    get buffered(): TimeRanges | null;
    get config(): any;
    configure(config?: any): void;
    get CorsType(): typeof CorsType;
    set crossOrigin(crossOrigin: string);
    get crossOrigin(): string | null;
    set currentTime(to: number);
    get currentTime(): number | null;
    // (undocumented)
    static get _defaultConfig(): any;
    get defaultPlaybackRate(): number;
    destroy(): void;
    detachMediaSource(): void;
    set dimensions(dimensions: PKDimensionsConfig);
    get dimensions(): PKPlayerDimensions;
    get duration(): number | null;
    enableAdaptiveBitrate(): void;
    get ended(): boolean | null;
    get EngineType(): typeof EngineType;
    get engineType(): string;
    enterFullscreen(elementId?: string): void;
    enterPictureInPicture(): void;
    get env(): IEnv;
    get Error(): typeof Error_2;
    get Event(): PKEventTypes;
    exitFullscreen(): void;
    exitPictureInPicture(): void;
    getActiveTracks(): {
        video: VideoTrack;
        audio: AudioTrack;
        text: TextTrack_2;
    };
    static getCapabilities(engineType?: string): Promise<{
        [name: string]: any;
    }>;
    // (undocumented)
    getDrmInfo(): PKDrmDataObject | null;
    getLogLevel(name?: string): ILogLevel;
    getNativeTextTracks(): Array<TextTrack>;
    getStartTimeOfDvrWindow(): number;
    _getTextTracks(): Array<TextTrack_2>;
    getThumbnail(time: number): ThumbnailInfo | null;
    getTracks<T extends Track | AudioTrack | TextTrack_2 | VideoTrack | ImageTrack>(type?: TrackTypes): T[];
    // (undocumented)
    getVideoElement(): HTMLVideoElement | undefined;
    getView(): HTMLElement;
    get hasUserInteracted(): boolean;
    hideBlackCover(): void;
    hideTextTrack(): void;
    isAdaptiveBitrateEnabled(): boolean;
    isAudio(): boolean;
    isDvr(): boolean;
    // (undocumented)
    isFullscreen(): boolean;
    isInPictureInPicture(): boolean;
    isLive(): boolean;
    isOnLiveEdge(): boolean;
    isPictureInPictureSupported(): boolean;
    isVr(): boolean;
    get liveDuration(): number | null;
    load(): void;
    set loadingMedia(loading: boolean);
    static _logger: ILogger;
    get LogLevel(): LoggerLevels;
    get LogLevelType(): Record<keyof LoggerLevels, keyof LoggerLevels>;
    get MediaType(): typeof MediaType;
    set muted(mute: boolean);
    get muted(): boolean | null;
    notifyEnterFullscreen(): void;
    notifyExitFullscreen(): void;
    _onTracksChanged(event: FakeEvent): void;
    pause(): void;
    get paused(): boolean | null;
    play(playOptions?: PKPlayOptionsObject): void;
    // Warning: (ae-forgotten-export) The symbol "PlaybackMiddleware" needs to be exported by the entry point playkit.d.ts
    get playbackMiddleware(): PlaybackMiddleware;
    set playbackRate(rate: number);
    get playbackRate(): number | null;
    get playbackRates(): Array<number>;
    set playsinline(playsinline: boolean);
    get playsinline(): boolean | null;
    get poster(): string;
    // Warning: (ae-forgotten-export) The symbol "PosterManager" needs to be exported by the entry point playkit.d.ts
    get posterManager(): PosterManager;
    ready(): Promise<void>;
    registerEngineDecoratorProvider(engineDecoratorProvider: IEngineDecoratorProvider): void;
    reset(isChangeMedia?: boolean): void;
    static runCapabilities(): void;
    get seeking(): boolean | null;
    seekToLiveEdge(): void;
    selectTrack(track?: Track): void;
    static setCapabilities(engineType: string, capabilities: {
        [name: string]: any;
    }): void;
    setLogLevel(level: ILogLevel, name?: string): void;
    setSources(sources: PKSourcesConfigObject): void;
    setSourcesMetadata(sourcesMetadata: PKMetadataConfigObject): void;
    setTextDisplaySettings(settings: PKTextTrackDisplaySettingObject): void;
    showBlackCover(): void;
    showTextTrack(): void;
    get sources(): PKSourcesConfigObject;
    get src(): string | null;
    get State(): typeof StateType;
    // (undocumented)
    get stats(): PKStatsObject;
    get StreamType(): typeof StreamType;
    get streamType(): string;
    // (undocumented)
    get textDisplaySetting(): any;
    get TextStyle(): typeof TextStyle;
    set textStyle(style: TextStyle);
    get textStyle(): TextStyle;
    get Track(): typeof TrackType;
    _updateTracks(tracks: Array<Track>): void;
    get videoHeight(): number | null;
    get videoWidth(): number | null;
    set volume(vol: number);
    get volume(): number | null;
}

// @public (undocumented)
export type PlayerStreamTypes = 'dash' | 'hls' | 'progressive' | 'image';

// Warning: (ae-forgotten-export) The symbol "EngineProvider" needs to be exported by the entry point playkit.d.ts
//
// @public (undocumented)
export const registerEngine: typeof EngineProvider.register;

// Warning: (ae-forgotten-export) The symbol "MediaSourceProvider" needs to be exported by the entry point playkit.d.ts
//
// @public (undocumented)
export const registerMediaSourceAdapter: typeof MediaSourceProvider.register;

// @public (undocumented)
export const RequestType: PKRequestType;

// @public
class ResizeWatcher extends FakeEventTarget {
    constructor();
    destroy(): void;
    init(el: HTMLElement): void;
}

// @public (undocumented)
export const ScreenOrientationType: PKOrientationType;

// @public (undocumented)
export const setCapabilities: typeof Player.setCapabilities;

// @public
export function setLogHandler(handler: ILogHandler): void;

// @public
export function setLogLevel(level: ILogLevel, name?: string): void;

// @public
export class State {
    constructor(type: string);
    get duration(): number;
    set duration(endTime: number);
    type: string;
}

// @public (undocumented)
export type StateChanged = {
    oldState: MaybeState;
    newState: MaybeState;
};

// @public (undocumented)
export const StateType: {
    readonly IDLE: "idle";
    readonly LOADING: "loading";
    readonly PLAYING: "playing";
    readonly PAUSED: "paused";
    readonly BUFFERING: "buffering";
};

// @public (undocumented)
export const StreamType: {
    readonly DASH: "dash";
    readonly HLS: "hls";
    readonly PROGRESSIVE: "progressive";
    readonly IMAGE: "image";
};

// @public (undocumented)
const _String: {
    capitlize: (string: string) => string;
    endsWith: (string: string, searchString: string) => boolean;
};

// @public
export class TextStyle {
    backgroundColor: [number, number, number];
    backgroundOpacity: number;
    clone(): TextStyle;
    static EdgeStyles: {
        [edgeStyle: string]: Array<[number, number, number, number, number, number]>;
    };
    fontColor: [number, number, number];
    fontEdge: Array<[number, number, number, number, number, number]>;
    static FontFamily: {
        [font: string]: string;
    };
    fontFamily: string;
    fontOpacity: number;
    set fontScale(fontScale: number);
    get fontScale(): FontScaleOptions;
    set fontSize(fontSize: string);
    get fontSize(): FontSizeOptions;
    static FontSizes: {
        label: FontSizeOptions;
        value: FontScaleOptions;
    }[];
    // (undocumented)
    static fromJson(setting: PKTextStyleObject): TextStyle;
    // (undocumented)
    getTextShadow(): string;
    // (undocumented)
    get implicitFontScale(): number;
    isEqual(textStyle: TextStyle): boolean;
    static StandardColors: {
        [coloer: string]: [number, number, number];
    };
    static StandardOpacities: {
        [opacityLevel: string]: number;
    };
    toCSS(): string;
    // (undocumented)
    static toJson(text: TextStyle): PKTextStyleObject;
    static toRGBA(color: [number, number, number], opacity: number): string;
}

// @public (undocumented)
class TextTrack_2 extends Track {
    // Warning: (ae-forgotten-export) The symbol "TrackSettings" needs to be exported by the entry point playkit.d.ts
    constructor(settings?: TrackSettings);
    // (undocumented)
    get default(): boolean;
    // (undocumented)
    get external(): boolean;
    // (undocumented)
    static EXTERNAL_TRACK_ID: string;
    // (undocumented)
    static _generateIndex(): number;
    // (undocumented)
    static isExternalTrack(track: any): boolean;
    // (undocumented)
    static isMetaDataTrack(track: any): boolean;
    // (undocumented)
    static isNativeTextTrack(track: any): boolean;
    // (undocumented)
    static KIND: Record<'METADATA' | 'SUBTITLES' | 'CAPTIONS', TextTrackKind>;
    // (undocumented)
    get kind(): string;
    // (undocumented)
    static MODE: Record<'DISABLED' | 'SHOWING' | 'HIDDEN', TextTrackMode>;
    // (undocumented)
    get mode(): string | undefined;
    set mode(mode: string);
    // (undocumented)
    static reset(): void;
}
export { TextTrack_2 as PKTextTrack }
export { TextTrack_2 as TextTrack }

// @public (undocumented)
export class ThumbnailInfo {
    constructor(info: {
        url: string;
        width: number;
        height: number;
        x: number;
        y: number;
    });
    // (undocumented)
    get height(): number;
    // (undocumented)
    get url(): string;
    // (undocumented)
    get width(): number;
    // (undocumented)
    get x(): number;
    // (undocumented)
    get y(): number;
}

// @public (undocumented)
export class TimedMetadata {
    constructor(startTime: number, endTime: number, id: string, type: string, metadata: any);
    // (undocumented)
    endTime: number;
    // (undocumented)
    id: string;
    // (undocumented)
    metadata: string | any;
    // (undocumented)
    startTime: number;
    // (undocumented)
    static TYPE: {
        [type: string]: string;
    };
    // (undocumented)
    type: string;
}

// @public
export class Track {
    constructor(settings?: any);
    get active(): boolean;
    set active(value: boolean);
    get available(): boolean;
    set available(isAvailable: boolean);
    // (undocumented)
    static clone<T>(track: any): T;
    clone: (...args: any[]) => any;
    get id(): number;
    get index(): number;
    set index(value: number);
    protected _index: number;
    get label(): string | undefined;
    set label(value: string);
    protected _label: string | undefined;
    static langComparer(inputLang: string, trackLang: string, additionalLanguage?: string, equal?: boolean): boolean;
    get language(): string;
}

// @public (undocumented)
export const TrackType: {
    readonly VIDEO: "video";
    readonly AUDIO: "audio";
    readonly TEXT: "text";
    readonly IMAGE: "image";
};

// @public (undocumented)
export type TrackTypes = 'video' | 'audio' | 'text' | 'image';

// @public (undocumented)
export type Transition = {
    [state: string]: {
        [event: string]: Function;
    };
};

// @public (undocumented)
export const unRegisterEngine: typeof EngineProvider.unRegister;

declare namespace Utils {
    export {
        ResizeWatcher,
        MultiMap,
        binarySearch,
        _Number as Number,
        _String as String,
        _Object as Object,
        _Generator as Generator,
        _Dom as Dom,
        _Http as Http,
        _VERSION as VERSION
    }
}
export { Utils }
export { Utils as utils }

// @public (undocumented)
export const VERSION: string;

// @public (undocumented)
const _VERSION: {
    compare: (v1: string, v2: string, options?: any) => number;
};

// @public
export class VideoTrack extends Track {
    constructor(settings?: any);
    // (undocumented)
    get bandwidth(): number;
    // (undocumented)
    get height(): number;
    // (undocumented)
    get width(): number;
}


export * from "js-logger";

// Warnings were encountered during analysis:
//
// src/types/sources-config.ts:13:3 - (ae-forgotten-export) The symbol "PKExternalCaptionObject" needs to be exported by the entry point playkit.d.ts
// src/utils/util.ts:504:4 - (ae-forgotten-export) The symbol "jsonp" needs to be exported by the entry point playkit.d.ts

// (No @packageDocumentation comment for this package)

```
